//--------------------------------------------------------------------------
/**
 * @file
 * @ingroup Had_snk
 * @brief   implementation of the (sink) hadron block for octet baryons
 * @author  HAL QCD Collaboration
 * @author  N. Ishii
 * @author  T. Doi, K. Sasaki
 */
//--------------------------------------------------------------------------

#ifdef _OPENMP
#include <omp.h>
#endif

#include <math.h>

#include <util/halqcd/HAL_config.h>
#include <util/halqcd/COMPLEX.h>
#include <util/halqcd/gjp_file_scope_cps.h>
#include <util/halqcd/Had_snk.h>
#include <util/halqcd/NBS_idx.h>


//#include <util/halqcd/debug.h>
HAL_START_NAMESPACE
using namespace NBS_idx;


static int spinor_offset;
static int spinor_BEGIN;
static int spinor_END;
static int vector_BEGIN;
static int vector_END;

//--------------------------------------------------------------------------
/**
 * @brief Evaluation of sink hadron block (wrapper func)
 */
//--------------------------------------------------------------------------

void Had_snk::diag_snk_Bdec(Float *snk, int pid)
{
  char *fname = "diag_snk_Bdec(Float*,int)";
  initialize_gjp_file_scope();

  if      ( tdir == TDIR_fw ) { spinor_offset = 0; }
  else if ( tdir == TDIR_bw ) { spinor_offset = 2; }
  else {
    ERR.General(cname,fname,"Unknown tdir = %d\n", tdir);
  }

  spinor_BEGIN = spinor_offset;
  vector_BEGIN = 0;
  vector_END = vector_BEGIN + 3;

  int dof;
  if ( flg_src_NR_Bdec ) { 
    dof = DOF_Bdec_pauli; 
    spinor_END   = spinor_offset + 2;}
  else  {
    dof = DOF_Bdec_dirac; 
    spinor_END   = spinor_offset + 4; 
    ERR.General(cname,fname,"can't use relaticesitic in decouplet  flg_src_NR_Bdec = %d\n", flg_src_NR_Bdec);
  }

  int nsize = XYZnodeSites * dof;

  for(int i = 0; i < NRI * nsize; i++) snk[i] = 0.0;

  if ( pid == PID_Omega )  { diag_snk_Omega_sub (snk); }
  /*
    when you add new decouplet baryon.
    add here
   */
  //  else if ( pid == PID_Lambda  )  { diag_snk_Lamb_uds_sub(snk); }
  else {
    ERR.General(cname,fname,"Not implemented yet: pid = %d\n", pid);
  }

  /////////// automatic anti-particle ///////////
  // only complex-conjugate is taken care of.
  // swap of index will be taken care of
  // when data are saved at src contraction.
  if ( flg_iT_folding && tdir == TDIR_bw ) {
    COMPLEX* snk_c = (COMPLEX*)snk;
    for(int i = 0; i < nsize; i++){
      snk_c[i] = Conj(snk_c[i]);
    }
  }
  //////////////////////////////////////////////

}

//--------------------------------------------------------------------------
/**
 * @brief Evaluation of sink hadron block (implemented for each baryon)
 */
//--------------------------------------------------------------------------

void Had_snk::diag_snk_Omega_sub (Float *snk)
{
  initialize_gjp_file_scope();
  for ( int mu = vector_BEGIN ; mu < vector_END ; mu++){ // mu = 0,1,2
    for(  int alpha  = spinor_BEGIN; alpha  < spinor_END; alpha++){
      PlusEq_Omega_snk(snk, alpha, mu, Prop_s(), 1.0);
    }
  }
}



//--------------------------------------------------------------------------
/**
 * @brief proton snk part
 */
//--------------------------------------------------------------------------

// calculate
//   Proton_alpha [ubar(c3P,alpha3P), dbar(c2P,alpha2P), ubar(c1P,alpha1P)]
// = Neutron_alpha[dbar(c3P,alpha3P), dbar(c1P,alpha1P), ubar(c2P,alpha2P)] (if isospin symmetry assumed)

// where
// snk indices: (alpha,mu)
// src indices: (c1P, alpha1P; c2P, alpha2P; c3P, alpha3P)

// input:
// SX_Float <==> propagator

// output:
// snk_Float <==> hadron sink block
// (this should be zero-cleared before call)

void Had_snk::PlusEq_Omega_snk(Float* snk_Float,
			       int    alpha,
			       int    mu, 
			       Float* SsX_Float,
			       Float  FactorP)
{
  char *fname = "PlusEq_Omega_snk(Float*, int, int, Float*, Float)";
  initialize_gjp_file_scope();

  Float perm_norm = 1.0 / 6.0 ;
  // permutation factor is not included here, but will be considered in (full) permutation (three strange qurks)at the source.
  // therefore, we normalize by 1/6 here to cancel the three s-quark permutation factor in the sink omega.

  int iT = iT_NBS_snk;

  COMPLEX* Snk = (COMPLEX*)snk_Float;
  COMPLEX* SsX = (COMPLEX*)SsX_Float;

  // quark spinor at the snk
  int spinor_offset_snk = 0;
  int alpha1_BEGIN =  0;
  int alpha1_END = 0;

  if ( flg_snk_NR_Bdec ){
    alpha1_END   = alpha1_BEGIN + ND_pauli;  // only Cgamma upper commponets
  }
  else {
    int alpha1_END   =  alpha1_BEGIN + ND_dirac;
    ERR.General(cname,fname,"can't use relaticesitic in decouplet  flg_snk_NR_Bdec = %d\n", flg_snk_NR_Bdec);
  }
  
  //  should modify
  if ( flg_snk_NR_Bdec ) {
    if ( tdir == TDIR_bw ) spinor_offset_snk = 2;
    alpha1_BEGIN = spinor_offset_snk;
    alpha1_END   = spinor_offset_snk + 2;
  }
 
  // quark spinor at the src
  int spinor_offset_src = 0;
  int alphaP_BEGIN = 0;
  int alphaP_END   = 0;

  if ( flg_src_NR_Bdec ) {
    if ( tdir == TDIR_bw ) spinor_offset_src = 2;
    alphaP_BEGIN = spinor_offset_src;
    alphaP_END   = spinor_offset_src + 2;
  }
  else {
    alphaP_END = spinor_offset_src + ND;
  }
  
  // loop for src
#pragma omp parallel for
  for(int cXP = 0; cXP < NC*NC*NC; cXP++){ 
    int c1P =  cXP % NC;
    int c2P = (cXP / NC) % NC;
    int c3P = (cXP / NC) / NC;

    for(int alpha3P = alphaP_BEGIN; alpha3P < alphaP_END; alpha3P++) {
    for(int alpha2P = alphaP_BEGIN; alpha2P < alphaP_END; alpha2P++) {
    for(int alpha1P = alphaP_BEGIN; alpha1P < alphaP_END; alpha1P++) {

      for(int ixyz = 0; ixyz < XYZnodeSites; ixyz++){

        for(int alpha1 = alpha1_BEGIN; alpha1 < alpha1_END; alpha1++){
          int   alpha2 = ICGM(alpha1,mu + 1);
          int   alpha3 = alpha;
          COMPLEX Factor = ZCGM(alpha1,mu + 1) * FactorP * perm_norm;
      
          for(int n=0; n<6; n++){
            int c1   = Eps(0,n);
            int c2   = Eps(1,n);
            int c3   = Eps(2,n);
            int sign = Eps(3,n);

            Snk[ Bdec_blk_idx(ixyz,  alpha - spinor_offset, mu,
                              c1P, alpha1P - spinor_offset_src,
                              c2P, alpha2P - spinor_offset_src,
                              c3P, alpha3P - spinor_offset_src, flg_src_NR_Bdec) ]
              += Factor * double(sign)
              * (   SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c2P,alpha2P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c3P,alpha3P,iT) ]
		    
		  - SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c3P,alpha3P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c2P,alpha2P,iT) ] 

		  - SsX[ prop_idx(c1,alpha1,ixyz,c2P,alpha2P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c1P,alpha1P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c3P,alpha3P,iT) ] 

		  + SsX[ prop_idx(c1,alpha1,ixyz,c2P,alpha2P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c3P,alpha3P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c1P,alpha1P,iT) ]

		  + SsX[ prop_idx(c1,alpha1,ixyz,c3P,alpha3P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c1P,alpha1P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c2P,alpha2P,iT) ] 

		  - SsX[ prop_idx(c1,alpha1,ixyz,c3P,alpha3P,iT) ] *
		    SsX[ prop_idx(c2,alpha2,ixyz,c2P,alpha2P,iT) ] *
		    SsX[ prop_idx(c3,alpha3,ixyz,c1P,alpha1P,iT) ]
		    
		     );

	    /*
	    	    printf ("Flag = %d  coef =  %g %g  prop = %g  %g      %g %g        %g %g\n",flg_src_NR_Bdec,  Real(Factor), Imag(Factor) ,
		    Real(SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,iT) ]),
		    Imag(SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,iT) ]),
		    Real(SsX[ prop_idx(c2,alpha2,ixyz,c2P,alpha2P,iT) ]),
		    Imag(SsX[ prop_idx(c2,alpha2,ixyz,c2P,alpha2P,iT) ]),
		    Real(SsX[ prop_idx(c3,alpha3,ixyz,c3P,alpha3P,iT) ]),
		    Imag(SsX[ prop_idx(c3,alpha3,ixyz,c3P,alpha3P,iT) ]));
	    */
	    /*	    printf("Snk_diagram =  %g  %g\n",Real(Snk[ Bdec_blk_idx(ixyz,  alpha - spinor_offset, mu,
						 c1P, alpha1P - spinor_offset_src,
						 c2P, alpha2P - spinor_offset_src,
						     c3P, alpha3P - spinor_offset_src, flg_src_NR_Bdec) ]),
		   Imag(Snk[ Bdec_blk_idx(ixyz,  alpha - spinor_offset, mu,
					  c1P, alpha1P - spinor_offset_src,
					  c2P, alpha2P - spinor_offset_src,
					  c3P, alpha3P - spinor_offset_src, flg_src_NR_Bdec) ]));
	    */
          } // for(int n=0; ...)

        } // for(int alpha1 = 0; ...)

      } // for(int ixyz = 0; ...)

    }
    }
    } // alpha1P, alpha2P, alpha3P

  } // cXP
  // end of pragma omp parallel for
  
//debug 
//s prop

/*
  NBSDBG DBG("",8*8*8);
  DBG.checkXyzAll(false);
  DBG.printProp(SsX_Float);
  DBG.print_dec_Had_blk(snk_Float,flg_src_NR_Bdec);
*/
  /* 
  for(int alpha3P = 0; alpha3P < 2; alpha3P++) {
  for(int alpha2P = 0; alpha2P < 2; alpha2P++) {
  for(int alpha1P = 0; alpha1P < 2; alpha1P++) {
  for(int c3P = 0; c3P < 3; c3P++) {
  for(int c2P = 0; c2P < 3; c2P++) {
  for(int c1P = 0; c1P < 3; c1P++) {

  for(int alpha3 = 0; alpha3 < 2; alpha3++) {
  for(int alpha2 = 0; alpha2 < 2; alpha2++) {
  for(int alpha1 = 0; alpha1 < 2; alpha1++) {
  for(int c3 = 0; c3 < 3; c3++) {
  for(int c2 = 0; c2 < 3; c2++) {
  for(int c1 = 0; c1 < 3; c1++) {

  for(int ixyz = 0; ixyz < 1; ixyz++){
    printf("prop_s %d %d %d :: %d %d %d  :: %d %d %d ::%d %d %d :: %g %g\n", c1, c2, c3, alpha1, alpha2, alpha3,  c1P, c2P, c3P, alpha1P, alpha2P, alpha3P, ixyz,
	   Real(SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,0) ]), 
	   Imag(SsX[ prop_idx(c1,alpha1,ixyz,c1P,alpha1P,0) ]));

}}}}}}}}}}}}}
//had block
  printf ("spinor_offset = %d\n", spinor_offset);
  for (int mu =0   ; mu< 3; mu ++ ){
  for(int alpha = 0; alpha < 2; alpha++) {
  for(int alpha3P = 0; alpha3P < 2; alpha3P++) {
  for(int alpha2P = 0; alpha2P < 2; alpha2P++) {
  for(int alpha1P = 0; alpha1P < 2; alpha1P++) {
  for(int c3P = 0; c3P < 3; c3P++) {
  for(int c2P = 0; c2P < 3; c2P++) {
  for(int c1P = 0; c1P < 3; c1P++) {

  for(int ixyz = 0; ixyz < 1; ixyz++){

		  printf("snk_bl %d %d :: %d %d %d  :: %d %d %d ::  %d :: %g %g\n",mu+1, alpha, alpha1P, alpha2P, alpha3P, c1P, c2P, c3P, ixyz,
			 Real(Snk[ Bdec_blk_idx(ixyz,  alpha - spinor_offset, mu,
						c1P, alpha1P - spinor_offset_src,
						c2P, alpha2P - spinor_offset_src,
						c3P, alpha3P - spinor_offset_src, flg_src_NR_Bdec) ]),
			 Imag(Snk[ Bdec_blk_idx(ixyz,  alpha - spinor_offset, mu,
						c1P, alpha1P - spinor_offset_src,
						c2P, alpha2P - spinor_offset_src,
						c3P, alpha3P - spinor_offset_src, flg_src_NR_Bdec) ])); 
  }}}}}}}}}
  */
//debug end
}

//--------------------------------------------------------------------------
/**
 * @brief projection to NR(non-rela)-limit in the snk
 */
//--------------------------------------------------------------------------
/*
void Had_snk::diag_snk_NR_proj(Float *snk_NR, Float *snk)
{
  char *fname = "diag_snk_NR_proj(Float*,Float*)";

  initialize_gjp_file_scope();

  int nc = NC;
  int nd = ND_pauli;
  int nv = ND_vec;

  int alp_offset = 0;
  if ( tdir == TDIR_bw ) alp_offset = 2;
  for(                int mu = 0; mu < nv; mu++)
      for(            int alp =0; alp <nd; alp++)
	for(          int alp3=0; alp3<nd; alp3++)
	  for(        int c3  =0; c3  <nc; c3++)
	    for(      int alp2=0; alp2<nd; alp2++)
	      for(    int c2  =0; c2  <nc; c2++)
		for(  int alp1=0; alp1<nd; alp1++)
		  for(int c1  =0; c1  <nc; c1++)
		    
		    for(int ixyz=0; ixyz<XYZnodeSites; ixyz++){
                  ((COMPLEX*)snk_NR) [ Bdec_blk_idx(ixyz, alp, mu, c1,alp1,              c2,alp2,              c3,alp3,              true ) ]
                    = ((COMPLEX*)snk)[ Bdec_blk_idx(ixyz, alp, mu, c1,alp1 + alp_offset, c2,alp2 + alp_offset, c3,alp3 + alp_offset, false) ];
                }

}
*/
//--------------------------------------------------------------------------


HAL_END_NAMESPACE
